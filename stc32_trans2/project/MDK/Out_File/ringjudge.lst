C251 COMPILER V5.60.0,  ringjudge                                                          16/07/23  02:26:04  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ringjudge
OBJECT MODULE PLACED IN .\Out_File\ringjudge.obj
COMPILER INVOKED BY: D:\keil5\C251\BIN\C251.EXE ..\CODE\ringjudge.c LARGE INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE
                    - INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER
                    -\inc;..\USER\src) DEBUG PRINT(.\Out_File\ringjudge.lst) OBJECT(.\Out_File\ringjudge.obj) 

stmt  level    source

    1          #include "ringjudge.h"
    2          #include "math.h"
    3          
    4          uint8 Ring_forecast = 0;
    5          int8 annulus_flag = 0;
    6          uint8 last_annulus_flag = 0;
    7          uint8 annulus_flag_k_index = 0;
    8          
    9          uint8 Ring_in = 0;
   10          uint8 Ring_running = 0;
   11          uint8 Ring_out = 0;
   12          uint8 Left_Annulus = 0;
   13          uint8 Ring_finish = 0;
   14          uint8 first_flag = 0;
   15          uint8 straight_flag = 0;
   16          uint16 gyro_x_count = 0;
   17          
   18          int8 many_ring = 0;
   19          
   20          uint8 angle_integral_flag1 = 0;
   21          uint8 angle_integral_flag2 = 0;
   22          uint8 distance_integral_flag1 = 0; //Â·³Ì»ý·Ö±êÖ¾Î»
   23          uint8 distance_integral_flag2 = 0; //Â·³Ì»ý·Ö±êÖ¾Î»
   24          
   25          uint8 if_first_dis1 = 0;
   26          int16 k_add = 0; // kÖµÀÛ¼Ó
   27          
   28          float angle1 = 0;
   29          float angle2 = 0;
   30          float obstacle_angle = 0;
   31          int16 distance1 = 0;
   32          int16 distance2 = 0;
   33          
   34          uint16 tof_count = 0;     //¼ÇÂ¼Ê®´ÎÖÐ²É¼¯µ½TOF¶ÁÊýÐ¡ÓÚ320µÄ´ÎÊý
   35          uint8 tof_count_flag = 0; //¼ì²âµ½ÕÏ°­ÎïµÄ´ÎÊý
   36          uint8 dodge_flag = 0;     //±ÜÕÏ±êÖ¾Î»
   37          
   38          void Ring_control(void)
   39          {
   40   1              last_annulus_flag = annulus_flag;
   41   1      
   42   1              //±àÂëÆ÷»ý·Ö
   43   1              if (distance_integral_flag1)
   44   1              {
   45   2                      distance1 += (abs(speedL) + abs(speedR)) / 2;
   46   2              }
   47   1      
   48   1              if (angle_integral_flag1)
   49   1              {
   50   2                      angle1 += gyro / 2922.22;
   51   2              }
   52   1      
   53   1              if (annulus_flag > 0)
   54   1              {
   55   2                      P77 = 1;
   56   2                      setSpeedLR(sp_set / 1.8);
   57   2              }
C251 COMPILER V5.60.0,  ringjudge                                                          16/07/23  02:26:04  PAGE 2   

   58   1              else
   59   1              {
   60   2                      P77 = 0;
   61   2              }
   62   1      
   63   1              Ring_forecast = 1;
   64   1      
   65   1              //----------Ô²»·Èë----------//
   66   1              if (adc_data[7] > 575 && annulus_flag == 0 && adc_data[1] < 350 && adc_data[3] < 350)
   67   1              {
   68   2                      Ring_in = 1;      //Ô²»·½øÈë±êÖ¾Î»
   69   2                      annulus_flag = 1; //´ò¿ª±êÖ¾Î»1
   70   2                      distance1 = 0;    //¾àÀë»ý·Ö
   71   2                      distance_integral_flag1 = 1;
   72   2                      k_add = 0;
   73   2                      angle_integral_flag1 = 1; //Æô¶¯ÍÓÂÝÒÇ»ý·Ö
   74   2              }
   75   1      
   76   1              if (annulus_flag == 1 && annulus_flag != 0)
   77   1              {
   78   2                      if (distance1 < dis1 && annulus_flag != 0)
   79   2                      {
   80   3                              if (adc_data[1] < adc_data[3])
   81   3                              {
   82   4                                      k_add += 1;
   83   4                              }
   84   3                              else
   85   3                              {
   86   4                                      k_add -= 1;
   87   4                              }
   88   3                      }
   89   2      
   90   2                      if (distance1 > dis1 && distance1 < dis2 && annulus_flag != 0) //¿ØÖÆ¹Ì¶¨´ò½ÇµÄÊ±¼ä50---100   ·Ç³£ÖØÒª£
             -¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡
   91   2                      {
   92   3                              if (first_flag == 0) //ÅÐ¶Ï»·Ïò
   93   3                              {
   94   4                                      if (adc_data[1] < adc_data[3])
   95   4                                      {
   96   5                                              Left_Annulus = 1;
   97   5                                      }
   98   4                                      first_flag = 1;
   99   4                              }
  100   3      
  101   3                              //Èç¹û¿ÉÒÔÊ¶±ðµ½Ô²»·£¬µ«ÊÇ½ø²»ÁËµÄ»°ÐÞ¸ÄÏÂÃæÕâÀï´ò½Ç·ù¶È»òÕßÐÞ¸ÄÉÏÃæµÄÊ±¼ä
  102   3                              if (Left_Annulus == 1) //×ó»·Èë
  103   3                              {
  104   4                                      // adc_data[0] = adc_data[3]+80;
  105   4                                      // k=-40;
  106   4                                      // if (adc_data[2] > 500)
  107   4                                      // {
  108   4                                      k = (-exp(-8*((float)(distance1-dis1)/(dis2-dis1)))+1)*-ring_set_k[annulus_flag_k_index];
  109   4                                      // }
  110   4      
  111   4                                      // pidR.setpoint *= 1.8;
  112   4                                      //      pwm_duty(PWB_CH1_P74,angle_max);  //Ç¿ÐÐÏò×ó´ò½Ç£¨ÓÒµç»ú¼ÓËÙ£©
  113   4                              }
  114   3                              else if (!Left_Annulus) //ÓÒ»·Èë
  115   3                              {
  116   4                                      // if (adc_data[2] > 500)
  117   4                                      // {
  118   4                                      k =  (-exp(-8*(((float)distance1-dis1)/(dis2-dis1)))+1)*ring_set_k[annulus_flag_k_index];
  119   4                                      // }
  120   4                                      // pidS.result = 2000;
  121   4                                      // pidL.setpoint *= 1.8;
  122   4                                      //  adc_data[3] = adc_data[0]+80;
C251 COMPILER V5.60.0,  ringjudge                                                          16/07/23  02:26:04  PAGE 3   

  123   4                                      //      pwm_duty(PWMB_CH1_P74,640); //Ç¿ÐÐÏòÓÒ´ò½Ç£¨×óµç»ú¼ÓËÙ£©
  124   4                              }
  125   3                      }
  126   2                      else if (distance1 >= dis2 && annulus_flag != 0) //¹Õ½øÈ¥ºóÕý³£Ñ­¼£
  127   2                      {
  128   3                              if_first_dis1 = 0;
  129   3                              annulus_flag = 2;
  130   3                              distance1 = 0;
  131   3                              distance_integral_flag1 = 1;
  132   3                              k_add = 0;
  133   3                      }
  134   2              }
  135   1              // else if (annulus_flag == 2)
  136   1              // {
  137   1              //      if (distance1 > 5000)
  138   1              //      {
  139   1              //              annulus_flag = many_ring;
  140   1              //              distance1 = 0;
  141   1              //              distance_integral_flag1 = 0; //Í£Ö¹Â·³Ì»ý·Ö
  142   1              //      }
  143   1              // }
  144   1              else if (annulus_flag == 2) //ÔÚ»·µºÄÚ
  145   1              {
  146   2                      if (abs(angle1) > 9500)
  147   2                      {
  148   3                              distance_integral_flag1 = 1; //¿ªÆôÂ·³Ì»ý·Ö
  149   3                              annulus_flag = -1;
  150   3                              // annulus_flag = 0; //³ö»·
  151   3                              annulus_flag_k_index++;
  152   3                      }
  153   2              }
  154   1              // else if (annulus_flag == 3) //´ò½Ç³ö»·
  155   1              // {
  156   1              //      if (distance1 < 2600 /*&&Annulus_Distance>500*/) //¿ØÖÆ¹Ì¶¨´ò½ÇµÄÊ±¼ä50---100   ·Ç³£ÖØÒª£¡£¡£¡£¡£¡£¡
             -£¡£¡£¡£¡£¡£¡
  157   1              //      {
  158   1              //              if (Left_Annulus == 1) //×ó»·³ö
  159   1              //              {
  160   1              //                      pidS.result = 1200;
  161   1              //              }
  162   1              //              else if (!Left_Annulus) //ÓÒ»·³ö
  163   1              //              {
  164   1              //                      pidS.result = -1200;
  165   1              //              }
  166   1              //      }
  167   1              //      else if (/*distance > 2600*/ 1) //»·µº½áÊø
  168   1              //      {
  169   1              //              annulus_flag = 4; //×ªÏò½áÊø
  170   1              //              distance1 = 0;
  171   1              //              distance_integral_flag1 = 1; //¼ÌÐøÂ·³Ì»ý·Ö·ÀÖ¹Ö±½Ó½øÈë»·µº
  172   1              //              k_add = 0;
  173   1              //      }
  174   1              // }
  175   1              // else if (annulus_flag == 4)
  176   1              // {
  177   1              //      if (distance1 > 10000)
  178   1              //      {
  179   1              //              all_reset();
  180   1              //      }
  181   1              // }
  182   1      
  183   1              //ÆÂµÀ·ÀÎóÅÐÎª»·µº
  184   1              if (abs(imu963ra_gyro_x) > 1000)
  185   1              {
  186   2                      gyro_x_count++;
  187   2              }
C251 COMPILER V5.60.0,  ringjudge                                                          16/07/23  02:26:04  PAGE 4   

  188   1              else
  189   1              {
  190   2                      gyro_x_count = 0;
  191   2              }
  192   1              if (gyro_x_count >= 3)
  193   1              {
  194   2                      all_reset();
  195   2              }
  196   1      }
  197          
  198          void obstacle_control(void)
  199          {
  200   1              if(dodge_flag == 1)
  201   1              {
  202   2                      P77 = 1;
  203   2              }else
  204   1              {
  205   2                      P77 = 0;
  206   2              }
  207   1              if (distance_integral_flag2)
  208   1              {
  209   2                      distance2 += (abs(speedL) + abs(speedR)) / 2;
  210   2              }
  211   1              if (1)
  212   1              {
  213   2                      obstacle_angle += gyro / 2922.22;
  214   2                      angle2 = MovingAverageFilter_0(obstacle_angle);
  215   2              }
  216   1              /***********************±ÜÕÏ******************************/
  217   1              if (dodge_flag == 0 && all_distance > 20000     /*&& leave_flag >= 3*/)
  218   1              {
  219   2                      //¼ì²âÊ®´Î  tof
  220   2                      if (tof_distance <= tof_dis)
  221   2                      {
  222   3                              tof_count++;
  223   3                      }
  224   2                      tof_count_flag++; //ÎïÌå¼ì²â´ÎÊý++
  225   2                      if (tof_count_flag == 10)
  226   2                      {
  227   3                              if (tof_count >= 8)
  228   3                              {
  229   4                                      dodge_flag++;
  230   4                                      distance2 = 0;
  231   4                              }
  232   3                              tof_count_flag = 0;
  233   3                      }
  234   2              }
  235   1              else if (dodge_flag == 1) //Òª×ª½Ç
  236   1              {
  237   2                      //×ó´ò½Ç
  238   2                      distance_integral_flag2 = 1;
  239   2                      angle_integral_flag2 = 1;
  240   2      //
  241   2                      pidS.result = exp(-((0.002*distance2*distance2)/(2.0*100*100)))*250;
  242   2                      if (angle2 > 25)
  243   2                      {
  244   3                              pidS.result = exp(-((0.002*distance2*distance2)/(2.0*100*100)))*250;;
  245   3                              // distance_integral_flag2 = 0;
  246   3                              // angle_integral_flag1 = 0;    //¹Ø±Õ½Ç¶È»ý·Ö
  247   3                              if (distance2 < tof_dis1)
  248   3                              {
  249   4                                      //²»×ö´¦Àí
  250   4                              }
  251   3                              else
  252   3                              {
  253   4                                      //distance_integral_flag2 = 0;
C251 COMPILER V5.60.0,  ringjudge                                                          16/07/23  02:26:04  PAGE 5   

  254   4                                      distance2 = 0;
  255   4                                      dodge_flag++;
  256   4                              }
  257   3                      }
  258   2              }
  259   1              else if (dodge_flag == 2)
  260   1              {
  261   2                      //´ò»ØÕýÏò
  262   2                      pidS.result = exp(-((0.002*distance2*distance2)/(2.0*100*100)))*-150;
  263   2                      if (/*straight_flag == 0 &&*/ angle2 < 8)
  264   2                      {
  265   3                              distance_integral_flag2 = 1;
  266   3                              if (distance2 < tof_dis2)
  267   3                              {
  268   4                                      pidS.result = 0;
  269   4                              }
  270   3                              else
  271   3                              {
  272   4                                      straight_flag = 1;
  273   4                                      distance_integral_flag2 = 0;
  274   4                                      distance2 = 0;
  275   4                                      dodge_flag++;
  276   4                              }
  277   3                      }
  278   2              }
  279   1      
  280   1              else if (dodge_flag == 3)
  281   1              {
  282   2                      distance_integral_flag2 = 1;
  283   2                      //ÓÒ´ò½Ç
  284   2                      pidS.result = exp(-((0.003*distance2*distance2)/(2.0*100*100)))*-125;
  285   2                      if (straight_flag==1 && angle2 < -22)
  286   2                      {
  287   3                              if(abs(pidS.result) > 200)
  288   3                              {
  289   4                                      pidS.result = 0;
  290   4                                      //²»×ö´¦Àí
  291   4                              }else
  292   3                              {
  293   4                                      pidS.result = exp(-((0.003*distance2*distance2)/(2.0*100*100)))*-125;
  294   4                              }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
             -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
             -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
             -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
             -                                                                                                                                                                                                                                                                                
  295   3                              dodge_flag++;
  296   3                              //                      distance1 = 0;
  297   3                              angle2 = 0;
  298   3                              //                      distance_integral_flag2 = 0;
  299   3                              //angle_integral_flag2 = 0;
  300   3                              //distance_integral_flag2 = 0;
  301   3                              distance2 = 0;
  302   3                      }
  303   2              }
  304   1              else if (dodge_flag == 4)
  305   1              {
  306   2                      distance_integral_flag2 = 1;
  307   2                      if(distance2 > 10000)
  308   2                      {
  309   3                              dodge_flag=5;
  310   3                              //obstacle_reset();
  311   3                      }
  312   2              }
  313   1      }
  314          
  315          void all_reset()
C251 COMPILER V5.60.0,  ringjudge                                                          16/07/23  02:26:04  PAGE 6   

  316          {
  317   1              angle = 0;
  318   1              distance1 = 0;
  319   1              Ring_forecast = 0;
  320   1              annulus_flag = 0;
  321   1              Ring_in = 0;
  322   1              Ring_running = 0;
  323   1              Ring_out = 0;
  324   1              Left_Annulus = 0;
  325   1              Ring_finish = 0;
  326   1              first_flag = 0;
  327   1              k_add = 0;
  328   1              // tof_count = 0;
  329   1              // dodge_flag = 0;
  330   1              // angle2 = 0;
  331   1              // distance2 = 0;
  332   1               angle_integral_flag1 = 0;
  333   1              // angle_integral_flag2 = 0;
  334   1               distance_integral_flag1 = 0; //Â·³Ì»ý·Ö±êÖ¾Î»
  335   1              // distance_integral_flag2 = 0; //Â·³Ì»ý·Ö±êÖ¾Î»
  336   1      }
  337          
  338          void obstacle_reset()
  339          {       
  340   1              tof_count = 0;
  341   1              dodge_flag = 0;
  342   1              angle2 = 0;
  343   1              distance2 = 0;
  344   1              //angle_integral_flag1 = 0;
  345   1              angle_integral_flag2 = 0;
  346   1              //distance_integral_flag1 = 0; //Â·³Ì»ý·Ö±êÖ¾Î»
  347   1              distance_integral_flag2 = 0; //Â·³Ì»ý·Ö±êÖ¾Î»
  348   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2053     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        41     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       176     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
