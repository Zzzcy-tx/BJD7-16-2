C251 COMPILER V5.60.0,  ringjudge                                                          17/07/23  20:10:16  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ringjudge
OBJECT MODULE PLACED IN .\Out_File\ringjudge.obj
COMPILER INVOKED BY: D:\Program files\Keil251\C251\BIN\C251.EXE ..\CODE\ringjudge.c LARGE INTR2 WARNINGLEVEL(3) OPTIMIZE
                    -(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral
                    -;..\CODE;..\USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\ringjudge.lst) TABS(2) OBJECT(.\Out_File\ringjudge.obj) 

stmt  level    source

    1          #include "ringjudge.h"
    2          #include "math.h"
    3          #include "data.h"
    4          
    5          uint8 Ring_forecast = 0;
    6          int8 annulus_flag = 0;
    7          uint8 last_annulus_flag = 0;
    8          uint8 annulus_flag_k_index = 0;
    9          
   10          uint8 Ring_in = 0;
   11          uint8 Ring_running = 0;
   12          uint8 Ring_out = 0;
   13          uint8 Left_Annulus = 0;
   14          uint8 Ring_finish = 0;
   15          uint8 first_flag = 0;
   16          uint8 straight_flag = 0;
   17          uint16 gyro_x_count = 0;
   18          
   19          int8 many_ring = 0;
   20          
   21          uint8 angle_integral_flag1 = 0;
   22          uint8 angle_integral_flag2 = 0;
   23          uint8 distance_integral_flag1 = 0; // 路程积分标志位
   24          uint8 distance_integral_flag2 = 0; // 路程积分标志位
   25          
   26          uint8 if_first_dis1 = 0;
   27          int16 k_add = 0; // k值累加
   28          
   29          float angle1 = 0; // 菜单显示积分
   30          float angle2 = 0;
   31          float obstacle_angle = 0;
   32          int16 distance1 = 0;
   33          int16 distance2 = 0;
   34          
   35          uint16 tof_count = 0;   // 记录十次中采集到TOF读数小于320的次数
   36          uint8 tof_count_flag = 0; // 检测到障碍物的次数
   37          uint8 dodge_flag = 0;   // 避障标志位
   38          int16 ringK = 0;
   39          
   40          void Ring_control(void)
   41          {
   42   1        last_annulus_flag = annulus_flag;
   43   1      
   44   1        // 编码器积分
   45   1        if (distance_integral_flag1)
   46   1        {
   47   2          distance1 += (abs(speedL) + abs(speedR)) / 2;
   48   2        }
   49   1      
   50   1        if (angle_integral_flag1)
   51   1        {
   52   2          angle1 += gyro / 2860;
   53   2        }
   54   1      
   55   1        if (annulus_flag > 0)
   56   1        {
   57   2          P77 = 1;
C251 COMPILER V5.60.0,  ringjudge                                                          17/07/23  20:10:16  PAGE 2   

   58   2          setSpeedLR(sp_set / 1.8);
   59   2        }
   60   1        else
   61   1        {
   62   2          P77 = 0;
   63   2        }
   64   1      
   65   1        Ring_forecast = 1;
   66   1      
   67   1        //----------圆环入----------//
   68   1        if (adc_data[7] > 575 && annulus_flag == 0 && adc_data[1] < 350 && adc_data[3] < 350)
   69   1        {
   70   2          Ring_in = 1;    // 圆环进入标志位
   71   2          annulus_flag = 1; // 打开标志位1
   72   2          distance1 = 0;    // 距离积分
   73   2          distance_integral_flag1 = 1;
   74   2          k_add = 0;
   75   2          angle_integral_flag1 = 1; // 启动陀螺仪积分
   76   2        }
   77   1      
   78   1        switch (PO_or_OBSTACLE[element_cnt]) // 根据圆环次序赋不同的dis1和dis2
   79   1        {
   80   2        case 0:
   81   2          ringK = ring_set_k[SMALLRING];
   82   2          dis1 = Ring_Dis1[SMALLRING];
   83   2          dis2 = Ring_Dis2[SMALLRING];
   84   2          break;
   85   2        case 1:
   86   2          ringK = ring_set_k[MIDRING];
   87   2          dis1 = Ring_Dis1[MIDRING];
   88   2          dis2 = Ring_Dis2[MIDRING];
   89   2          break;
   90   2        case 2:
   91   2          ringK = ring_set_k[BIGRING];
   92   2          dis1 = Ring_Dis1[BIGRING];
   93   2          dis2 = Ring_Dis2[BIGRING];
   94   2          break;
   95   2        }
   96   1      
   97   1        element_cnt = element_cnt + 1 - 2 * start_diration; // 根据发车方向不同加减element_cnt,左加右减
   98   1      
   99   1        if (annulus_flag == 1 && annulus_flag != 0)
  100   1        {
  101   2          if (distance1 < dis1 && annulus_flag != 0)
  102   2          {
  103   3            if (adc_data[1] < adc_data[3])
  104   3            {
  105   4              k_add += 1;
  106   4            }
  107   3            else
  108   3            {
  109   4              k_add -= 1;
  110   4            }
  111   3          }
  112   2      
  113   2          if (distance1 > dis1 && distance1 < dis2 && annulus_flag != 0) // 控制固定打角的时间50---100
  114   2          {
  115   3            if (first_flag == 0) // 判断环向
  116   3            {
  117   4              if (adc_data[1] < adc_data[3])
  118   4              {
  119   5                Left_Annulus = 1;
  120   5              }
  121   4              first_flag = 1;
  122   4            }
  123   3      
C251 COMPILER V5.60.0,  ringjudge                                                          17/07/23  20:10:16  PAGE 3   

  124   3            // 如果可以识别到圆环，但是进不了的话修改下面这里打角幅度或者修改上面的时间
  125   3            if (Left_Annulus == 1) // 左环入
  126   3            {
  127   4              // adc_data[0] = adc_data[3]+80;
  128   4              // k=-40;
  129   4              // if (adc_data[2] > 500)
  130   4              // {
  131   4              k = (-exp(-8 * ((float)(distance1 - dis1) / (dis2 - dis1))) + 1) * -ringK;
  132   4              // }
  133   4      
  134   4              // pidR.setpoint *= 1.8;
  135   4              //  pwm_duty(PWB_CH1_P74,angle_max);  //强行向左打角（右电机加速）
  136   4            }
  137   3            else if (!Left_Annulus) // 右环入
  138   3            {
  139   4              // if (adc_data[2] > 500)
  140   4              // {
  141   4              k = (-exp(-8 * (((float)distance1 - dis1) / (dis2 - dis1))) + 1) * ringK;
  142   4              // }
  143   4              // pidS.result = 2000;
  144   4              // pidL.setpoint *= 1.8;
  145   4              //  adc_data[3] = adc_data[0]+80;
  146   4              //  pwm_duty(PWMB_CH1_P74,640); //强行向右打角（左电机加速）
  147   4            }
  148   3          }
  149   2          else if (distance1 >= dis2 && annulus_flag != 0) // 拐进去后正常循迹
  150   2          {
  151   3            if_first_dis1 = 0;
  152   3            annulus_flag = 2;
  153   3            distance1 = 0;
  154   3            distance_integral_flag1 = 1;
  155   3            k_add = 0;
  156   3          }
  157   2        }
  158   1        // else if (annulus_flag == 2)
  159   1        // {
  160   1        //  if (distance1 > 5000)
  161   1        //  {
  162   1        //    annulus_flag = many_ring;
  163   1        //    distance1 = 0;
  164   1        //    distance_integral_flag1 = 0; //停止路程积分
  165   1        //  }
  166   1        // }
  167   1        else if (annulus_flag == 2) // 在环岛内
  168   1        {
  169   2          if (abs(angle1) > 9500)
  170   2          {
  171   3            distance_integral_flag1 = 1; // 开启路程积分
  172   3            annulus_flag = -1;
  173   3            // annulus_flag = 0; //出环
  174   3            annulus_flag_k_index++;
  175   3          }
  176   2        }
  177   1        // else if (annulus_flag == 3) //打角出环
  178   1        // {
  179   1        //  if (distance1 < 2600 /*&&Annulus_Distance>500*/) //控制固定打角的时间50---100   非常重要！！！！！！
             -！！！！！！
  180   1        //  {
  181   1        //    if (Left_Annulus == 1) //左环出
  182   1        //    {
  183   1        //      pidS.result = 1200;
  184   1        //    }
  185   1        //    else if (!Left_Annulus) //右环出
  186   1        //    {
  187   1        //      pidS.result = -1200;
  188   1        //    }
C251 COMPILER V5.60.0,  ringjudge                                                          17/07/23  20:10:16  PAGE 4   

  189   1        //  }
  190   1        //  else if (/*distance > 2600*/ 1) //环岛结束
  191   1        //  {
  192   1        //    annulus_flag = 4; //转向结束
  193   1        //    distance1 = 0;
  194   1        //    distance_integral_flag1 = 1; //继续路程积分防止直接进入环岛
  195   1        //    k_add = 0;
  196   1        //  }
  197   1        // }
  198   1        // else if (annulus_flag == 4)
  199   1        // {
  200   1        //  if (distance1 > 10000)
  201   1        //  {
  202   1        //    all_reset();
  203   1        //  }
  204   1        // }
  205   1      
  206   1        // 坡道防误判为环岛
  207   1        if (abs(imu963ra_gyro_x) > 1000)
  208   1        {
  209   2          gyro_x_count++;
  210   2        }
  211   1        else
  212   1        {
  213   2          gyro_x_count = 0;
  214   2        }
  215   1        if (gyro_x_count >= 3)
  216   1        {
  217   2          all_reset();
  218   2        }
  219   1      }
  220          
  221          void obstacle_control(void)
  222          {
  223   1        if (dodge_flag == 1)
  224   1        {
  225   2          P77 = 1;
  226   2        }
  227   1        else
  228   1        {
  229   2          P77 = 0;
  230   2        }
  231   1        if (distance_integral_flag2)
  232   1        {
  233   2          distance2 += (spL + spR) * 0.005 / 2;
  234   2        }
  235   1        if (1)
  236   1        {
  237   2          obstacle_angle += gyro / 2922.22;
  238   2          angle2 = MovingAverageFilter_0(obstacle_angle);
  239   2        }
  240   1        /***********************避障******************************/
  241   1        if (dodge_flag == 0 && all_distance > 20000 /*&& leave_flag >= 3*/)
  242   1        {
  243   2          // 检测十次  tof
  244   2          if (tof_distance <= tof_dis)
  245   2          {
  246   3            tof_count++;
  247   3          }
  248   2          tof_count_flag++; // 物体检测次数++
  249   2          if (tof_count_flag == 10)
  250   2          {
  251   3            if (tof_count >= 8)
  252   3            {
  253   4              distance2 = 0;
  254   4              distance_integral_flag2 = 1; // 开始积分距离
C251 COMPILER V5.60.0,  ringjudge                                                          17/07/23  20:10:16  PAGE 5   

  255   4      
  256   4              angle1 = 0;
  257   4              angle_integral_flag1 = 1; // 开始积分角度
  258   4      
  259   4              dodge_flag++;
  260   4            }
  261   3            tof_count_flag = 0;
  262   3          }
  263   2        }
  264   1        else if (dodge_flag == 1) // 要转角
  265   1        {
  266   2          // 左打角
  267   2          pidS.setpoint = exp(-((0.002 * distance2 * distance2) / (2.0 * 100 * 100))) * 250;
  268   2          if (angle1 > 25 && distance2 > 40)
  269   2          {
  270   3            angle1 = 0;
  271   3            distance2 = 0;
  272   3            dodge_flag++;
  273   3          }
  274   2        }
  275   1        else if (dodge_flag == 2)
  276   1        {
  277   2          // 打回正向
  278   2          pidS.result = exp(-((0.002 * distance2 * distance2) / (2.0 * 100 * 100))) * -150;
  279   2          if (angle1 < -25 && distance2 > 40)
  280   2          {
  281   3            angle1 = 0;
  282   3            distance2 = 0;
  283   3            dodge_flag++;
  284   3          }
  285   2        }
  286   1        else if (dodge_flag == 3)
  287   1        {
  288   2          // 右打角
  289   2          pidS.result = exp(-((0.003 * distance2 * distance2) / (2.0 * 100 * 100))) * -125;
  290   2          if (angle1 < -25 && distance2 > 40)
  291   2          {
  292   3            angle1 = 0;
  293   3            distance2 = 0;
  294   3            dodge_flag++;
  295   3          }
  296   2        }
  297   1        else if (dodge_flag == 4)
  298   1        {
  299   2          // 左打角回正
  300   2          pidS.result = exp(-((0.003 * distance2 * distance2) / (2.0 * 100 * 100))) * 125;
  301   2          if (angle1 > 25 && distance2 > 40)
  302   2          {
  303   3            angle1 = 0;
  304   3            distance2 = 0;
  305   3      
  306   3            distance_integral_flag2 = 0; // 停止路程积分
  307   3            angle_integral_flag1 = 0;  // 停止角度积分
  308   3      
  309   3            dodge_flag++;
  310   3          }
  311   2        }
  312   1        else if (dodge_flag == 5)
  313   1        {
  314   2          distance_integral_flag2 = 1;
  315   2          if (distance2 > 10000)
  316   2          {
  317   3            dodge_flag = 6;
  318   3            // obstacle_reset();  //继续避障则取消注释
  319   3          }
  320   2        }
C251 COMPILER V5.60.0,  ringjudge                                                          17/07/23  20:10:16  PAGE 6   

  321   1      }
  322          
  323          void all_reset()
  324          {
  325   1        angle = 0;
  326   1        distance1 = 0;
  327   1        Ring_forecast = 0;
  328   1        annulus_flag = 0;
  329   1        Ring_in = 0;
  330   1        Ring_running = 0;
  331   1        Ring_out = 0;
  332   1        Left_Annulus = 0;
  333   1        Ring_finish = 0;
  334   1        first_flag = 0;
  335   1        k_add = 0;
  336   1        // tof_count = 0;
  337   1        // dodge_flag = 0;
  338   1        // angle2 = 0;
  339   1        // distance2 = 0;
  340   1        angle_integral_flag1 = 0;
  341   1        // angle_integral_flag2 = 0;
  342   1        distance_integral_flag1 = 0; // 路程积分标志位
  343   1        // distance_integral_flag2 = 0; //路程积分标志位
  344   1      }
  345          
  346          void obstacle_reset()
  347          {
  348   1        tof_count = 0;
  349   1        dodge_flag = 0; // 重新避障
  350   1      
  351   1        angle2 = 0;
  352   1        angle_integral_flag2 = 0;
  353   1      
  354   1        angle1 = 0;
  355   1        angle_integral_flag1 = 0;
  356   1      
  357   1        distance2 = 0;
  358   1        distance_integral_flag2 = 0;
  359   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2205     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        43     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       183     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
