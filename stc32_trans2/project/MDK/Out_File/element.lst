C251 COMPILER V5.60.0,  element                                                            16/07/23  17:53:00  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE element
OBJECT MODULE PLACED IN .\Out_File\element.obj
COMPILER INVOKED BY: D:\Program files\Keil251\C251\BIN\C251.EXE ..\CODE\element.c LARGE INTR2 WARNINGLEVEL(3) OPTIMIZE(0
                    -,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;.
                    -.\CODE;..\USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\element.lst) TABS(2) OBJECT(.\Out_File\element.obj) 

stmt  level    source

    1          #include "element.h"
    2          #define HALL_PIN P26
    3          uint8 leave_flag = 0;             //出库阶段0:直行阶段1:右转阶段2:正常行驶
    4          float angle = 0;                  //角速度积分量，即旋转角度，全局变量
    5          uint8 angle_integral_flag = 0;    //角速度积分标志位，1为启用
    6          int16 distance = 0;               //路程积分，1为启用，全局变量
    7          uint8 distance_integral_flag = 0; //路程积分标志位
    8          uint8 into_flag = 1;              //入库阶段1:选择2:倒车
    9          uint8 hall_trigged = 0;
   10          
   11          // control函数在renew函数中被循环调用
   12          void control()
   13          {
   14   1          //陀螺仪积分
   15   1          if (angle_integral_flag)
   16   1          {
   17   2              angle += gyro * 0.005;
   18   2          }
   19   1      
   20   1          //编码器积分
   21   1          if (distance_integral_flag)
   22   1          {
   23   2              distance += (speedL + speedR) / 2;
   24   2          }
   25   1      
   26   1          //出库
   27   1          if (leave_flag == 0 && sp_set != 0)
   28   1          {
   29   2              distance_integral_flag = 1; //启动路程积分
   30   2              pidL.setpoint = 80;
   31   2              pidR.setpoint = 80;
   32   2              hall_trigged = 0;
   33   2              //直线行驶一段距离
   34   2      
   35   2              if (distance >= 3600)
   36   2              {
   37   3                  leave_flag++;
   38   3                  distance = 0;
   39   3                  distance_integral_flag = 0; //关闭路程积分
   40   3              }
   41   2          }
   42   1          else if (leave_flag == 1)
   43   1          {
   44   2              angle_integral_flag = 1; //启动陀螺仪积分
   45   2              if (start_diration == 0)
   46   2              {
   47   3                  pidL.setpoint = 0; //转
   48   3                  pidR.setpoint = 90;
   49   3              }
   50   2              else
   51   2              {
   52   3                  pidL.setpoint = 90; //转
   53   3                  pidR.setpoint = 0;
   54   3              }
   55   2      
   56   2              hall_trigged = 0;
   57   2              if (fabs(angle) >= 700)
C251 COMPILER V5.60.0,  element                                                            16/07/23  17:53:00  PAGE 2   

   58   2              {
   59   3                  angle_integral_flag = 0; //关闭陀螺仪积分
   60   3                  angle = 0;               //角度复位
   61   3                  leave_flag++;
   62   3                  hall_trigged = 0;
   63   3              }
   64   2          }
   65   1          else if (leave_flag == 2)
   66   1          {
   67   2              distance_integral_flag = 1; //启动路程积分
   68   2              hall_trigged = 0;           //防止直接进入入库模式
   69   2              if (distance >= 15000)
   70   2              {
   71   3                  leave_flag++;
   72   3                  distance_integral_flag = 0; //关闭路程积分
   73   3                  distance = 0;
   74   3              }
   75   2          }
   76   1      
   77   1          if (HALL_PIN == 0)
   78   1          {
   79   2              hall_trigged = 1;
   80   2          }
   81   1      
   82   1          //入库
   83   1          if (into_flag == 1 && hall_trigged == 1)
   84   1          {
   85   2              distance_integral_flag = 1;
   86   2              if (distance >= ku_distance)
   87   2              {
   88   3                  sp_set = 0;
   89   3                  if ((speedL + speedR) / 2 <= 7)
   90   3                  {
   91   4                      into_flag++;
   92   4                      distance_integral_flag = 0;
   93   4                      distance = 0;
   94   4                  }
   95   3              }
   96   2          }
   97   1          else if (into_flag == 2) //旋转90°
   98   1          {
   99   2              angle_integral_flag = 1;
  100   2              if (start_diration == 0)
  101   2              {
  102   3                  setSpeedL(-(int16)((2 * into_R - 0.18) / (2 * into_R + 0.18) * (float)aimed_into_speed));
  103   3                  setSpeedR(-aimed_into_speed);
  104   3              }
  105   2              else
  106   2              {
  107   3                  setSpeedL(-aimed_into_speed);
  108   3                  setSpeedR(-(int16)((2 * into_R - 0.18) / (2 * into_R + 0.18) * (float)aimed_into_speed));
  109   3              }
  110   2      
  111   2              // setPidLR(27.4, 12, 0, 9000);
  112   2              // setPidW(3.68, 0, 9.86);
  113   2              // angle_integral_flag = 1;      //启动陀螺仪积分
  114   2              // pidW.setpoint = -2500;        //角度环目标值(即90度)
  115   2              // PIDRegulation1(&pidW, angle); //角度环计算
  116   2              // // setSpeedL(-pidW.result / 100 * 3 / 30); //设置目标速度
  117   2              // setSpeedL(0);
  118   2              // setSpeedR(-pidW.result / 100); //设置目标速度
  119   2              if (fabs(angle) >= 2100) //积分量达到目标(90度不到一点)
  120   2              {
  121   3                  into_flag++;
  122   3                  // sp_set = 0;
  123   3              }
C251 COMPILER V5.60.0,  element                                                            16/07/23  17:53:00  PAGE 3   

  124   2          }
  125   1          else if (into_flag == 3) //直线倒车
  126   1          {
  127   2              // setPidW(6, 0, 11);                  //角度环参数，距离太短不太好调
  128   2              // pidW.setpoint = -2500;              //角度环目标值
  129   2              // PIDRegulation1(&pidW, angle);       // PID计算
  130   2              // setSpeedR(-pidW.result / 90 - 100); //速度设定
  131   2              // setSpeedL(pidW.result / 90 - 100);  //速度设定
  132   2              setSpeedLR(-aimed_into_speed);
  133   2              distance_integral_flag = 1; //启动路程积分
  134   2      
  135   2              if (distance <= -2000) //到达目标距离
  136   2              {
  137   3                  into_flag++;                //入库完成
  138   3                  distance = 0;               //距离复位
  139   3                  distance_integral_flag = 0; //关闭路程积分
  140   3                  angle_integral_flag = 0;    //关闭陀螺仪积分
  141   3                  angle = 0;                  //角度复位
  142   3                  sp_set = 0;                 //停车
  143   3              }
  144   2          }
  145   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       925     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        11     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        46     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
