C251 COMPILER V5.60.0,  element                                                            16/07/23  02:20:41  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE element
OBJECT MODULE PLACED IN .\Out_File\element.obj
COMPILER INVOKED BY: D:\keil5\C251\BIN\C251.EXE ..\CODE\element.c LARGE INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE I
                    -NCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\i
                    -nc;..\USER\src) DEBUG PRINT(.\Out_File\element.lst) OBJECT(.\Out_File\element.obj) 

stmt  level    source

    1          #include "element.h"
    2          #define HALL_PIN P26
    3          uint8 leave_flag = 0;             //出库阶段0:直行阶段1:右转阶段2:正常行驶
    4          float angle = 0;                  //角速度积分量，即旋转角度，全局变量
    5          uint8 angle_integral_flag = 0;    //角速度积分标志位，1为启用
    6          int16 distance = 0;               //路程积分，1为启用，全局变量
    7          uint8 distance_integral_flag = 0; //路程积分标志位
    8          uint8 into_flag = 1;              //入库阶段1:选择2:倒车
    9          uint8 hall_trigged = 0;
   10          
   11          // control函数在renew函数中被循环调用
   12          void control()
   13          {
   14   1          //陀螺仪积分
   15   1          if (angle_integral_flag)
   16   1          {
   17   2              angle += gyro * 0.01;
   18   2          }
   19   1      
   20   1          //编码器积分
   21   1          if (distance_integral_flag)
   22   1          {
   23   2              distance += (speedL + speedR) / 2;
   24   2          }
   25   1      
   26   1          //出库
   27   1          if (leave_flag == 0 && sp_set != 0)
   28   1          {
   29   2              distance_integral_flag = 1; //启动路程积分
   30   2              pidL.setpoint = 100;
   31   2              pidR.setpoint = 100;
   32   2              hall_trigged = 0;
   33   2              //直线行驶一段距离
   34   2              if (distance >= 3600)
   35   2              {
   36   3                  leave_flag++;
   37   3                  distance = 0;
   38   3                  distance_integral_flag = 0; //关闭路程积分
   39   3              }
   40   2          }
   41   1          else if (leave_flag == 1)
   42   1          {
   43   2              angle_integral_flag = 1; //启动陀螺仪积分
   44   2              if (start_diration == 0)
   45   2              {
   46   3                  pidL.setpoint = 0; //转
   47   3                  pidR.setpoint = 90;
   48   3              }
   49   2              else
   50   2              {
   51   3                  pidL.setpoint = 90; //转
   52   3                  pidR.setpoint = 0;
   53   3              }
   54   2      
   55   2              hall_trigged = 0;
   56   2              if (fabs(angle) >= 700)
   57   2              {
C251 COMPILER V5.60.0,  element                                                            16/07/23  02:20:41  PAGE 2   

   58   3                  angle_integral_flag = 0; //关闭陀螺仪积分
   59   3                  angle = 0;               //角度复位
   60   3                  leave_flag++;
   61   3                  hall_trigged = 0;
   62   3              }
   63   2          }
   64   1          else if (leave_flag == 2)
   65   1          {
   66   2              distance_integral_flag = 1; //启动路程积分
   67   2              hall_trigged = 0;           //防止直接进入入库模式
   68   2              if (distance >= 15000)
   69   2              {
   70   3                  leave_flag++;
   71   3                  distance_integral_flag = 0; //关闭路程积分
   72   3                  distance = 0;
   73   3              }
   74   2          }
   75   1      
   76   1          if (HALL_PIN == 0)
   77   1          {
   78   2              hall_trigged = 1;
   79   2          }
   80   1      
   81   1          //入库
   82   1          if (into_flag == 1 && hall_trigged == 1)
   83   1          {
   84   2              distance_integral_flag = 1;
   85   2              if (distance >= ku_distance)
   86   2              {
   87   3                  sp_set = 0;
   88   3                  if ((speedL + speedR) / 2 <= 7)
   89   3                  {
   90   4                      into_flag++;
   91   4                      distance_integral_flag = 0;
   92   4                      distance = 0;
   93   4                  }
   94   3              }
   95   2          }
   96   1          else if (into_flag == 2) //旋转90°
   97   1          {
   98   2              angle_integral_flag = 1;
   99   2              if (start_diration == 0)
  100   2              {
  101   3                  setSpeedL(-(int16)((2 * into_R - 0.18) / (2 * into_R + 0.18) * (float)aimed_into_speed));
  102   3                  setSpeedR(-aimed_into_speed);
  103   3              }
  104   2              else
  105   2              {
  106   3                  setSpeedL(-aimed_into_speed);
  107   3                  setSpeedR(-(int16)((2 * into_R - 0.18) / (2 * into_R + 0.18) * (float)aimed_into_speed));
  108   3              }
  109   2      
  110   2              // setPidLR(27.4, 12, 0, 9000);
  111   2              // setPidW(3.68, 0, 9.86);
  112   2              // angle_integral_flag = 1;      //启动陀螺仪积分
  113   2              // pidW.setpoint = -2500;        //角度环目标值(即90度)
  114   2              // PIDRegulation1(&pidW, angle); //角度环计算
  115   2              // // setSpeedL(-pidW.result / 100 * 3 / 30); //设置目标速度
  116   2              // setSpeedL(0);
  117   2              // setSpeedR(-pidW.result / 100); //设置目标速度
  118   2              if (fabs(angle) >= 2100) //积分量达到目标(90度不到一点)
  119   2              {
  120   3                  into_flag++;
  121   3                  // sp_set = 0;
  122   3              }
  123   2          }
C251 COMPILER V5.60.0,  element                                                            16/07/23  02:20:41  PAGE 3   

  124   1          else if (into_flag == 3) //直线倒车
  125   1          {
  126   2              // setPidW(6, 0, 11);                  //角度环参数，距离太短不太好调
  127   2              // pidW.setpoint = -2500;              //角度环目标值
  128   2              // PIDRegulation1(&pidW, angle);       // PID计算
  129   2              // setSpeedR(-pidW.result / 90 - 100); //速度设定
  130   2              // setSpeedL(pidW.result / 90 - 100);  //速度设定
  131   2              setSpeedLR(-aimed_into_speed);
  132   2              distance_integral_flag = 1; //启动路程积分
  133   2      
  134   2              if (distance <= -2000) //到达目标距离
  135   2              {
  136   3                  into_flag++;                //入库完成
  137   3                  distance = 0;               //距离复位
  138   3                  distance_integral_flag = 0; //关闭路程积分
  139   3                  angle_integral_flag = 0;    //关闭陀螺仪积分
  140   3                  angle = 0;                  //角度复位
  141   3                  sp_set = 0;                 //停车
  142   3              }
  143   2          }
  144   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       925     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        11     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        46     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
